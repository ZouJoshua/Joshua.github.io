<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows下配置TensorFlow]]></title>
    <url>%2F2017%2F08%2F25%2FWindows%E4%B8%8B%E9%85%8D%E7%BD%AETensorFlow%2F</url>
    <content type="text"><![CDATA[前言 现在人人都谈AI，不了解点深度学习，真实不好意思说自己是做DS的，所以打算也入坑了解下，不然以后怎么和别人吹（^_^），所以今天先深度学习框架环境搭建起来，在本地学习下，本博文记录了自己在 Win10 上搭建深度学习环境 TensorFlow 的一些步骤及遇到的一些问题。 个人电脑配置及环境由于 TensorFlow 配置需要 CUDA 和 CUDNN 版本匹配才能正常运行，而 NVIDIA 更新这两个产品不同步，所以对于不同的 CUDA 版本，所需的 cuDNN 是固定的，因此时间不同，安装的版本是不一样的，而本博文更新日期为：2017/8/28，各位查看配置信息时，需注意此点。 笔记本配置OS ： Windows 10 64bit CPU ： Intel Core i7-7500U(2.7GHz/L3 4M) 内存 ： 8G 显卡 ： NVIDIA GeForce 940MX 开发环境Python ： Python 3.5.2 |Continuum Analytics, Inc.| (default, Jul 5 2016, 11:41:13) [MSC v.1900 64 bit (AMD64)] on win32 TensorFlow ： 1.3.0 CUDA ： Cuda compilation tools, release 8.0, V8.0.60 cuDNN ： cuDNN v6.0 (April 27, 2017), for CUDA 8.0 创建虚拟环境12# 创建tensorflow虚拟环境，自定义路径，（TensorFlow在Windows上只支持64位Python3.5）conda create -n tensorflow python=3.5.2 TensorFlow 安装确定安装那个版本的TensorFlow： 仅支持CPU运算版本： 如果电脑的系统没有NVIDIA显卡，不支持GPU，那么必须安装这个版本。 支持GPU运算版本： TensorFlow程序在GPU下运行比在CPU下运行明显快很多，但是需要 CUDA 和 cuDNN 的支持，性能还可以建议安装此版本，在 这里 确认你的显卡支持 CUDA。 虽然我的NVIDIA显卡并不特别出色，计算能力5.0，从计算效率上考虑还是打算安装GPU运算版本。如果查看自己的电脑支持GPU，那么可以开始下载 CUDA 和 cuDNN 的安装包了，注意版本号分别是 CUDA 8.0 和 cuDNN 6.0（由于 TensorFlow 不同版本有变化，5.1 已不再适用新版本）。 安装 CUDA 和 CUDNN 驱动 CUDA 安装 下载完成可以进行安装，exe 文件就是 CUDA8 的安装程序，直接双击执行（尽量关闭360，如果不想关闭，弹出修改程序的内容的话就点允许，否则安装会出问题），安装完之后系统变量会自动添加上。 测试是否安装成功，打开CMD窗口，命令行输入 nvcc -V 。 CUDNN 安装 Google 于 2017 年 8 月 17 日左右发布了 TensorFlow 1.3，该版本不再支持 cuDNN 5，开始支持 cuDNN 6，并预计在 TensorFlow 1.4 支持 cuDNN 7，所以说当你使用 pip 安装最新版的时候，请使用 cuDNN 6，否则会出现 ImportError: DLL load failed: 找不到指定的模块。 和 ImportError: No module named &#39;_pywrap_tensorflow_internal&#39; 的问题。 当下载完成后，解压后将文件复制进入C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0，并将该目录下的这三个目录加进 Path 环境变量 安装 TensorFlow12345# 进入tensorflow环境，并激活环境cd tensorflow/scripts activate# 安装 tensorflow（GPU版本）pip install tensorflow-gpu 测试1234567import tensorflow as tfa = tf.random_normal((100, 100))b = tf.random_normal((100, 500))c = tf.matmul(a, b)sess = tf.InteractiveSession()sess.run(c) 至此，安装就完成了，接下来就可以着手项目练练手了（PS：暴露了我的渣显卡，请勿吐槽。）。]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>机器学习</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Numpy速度的一些思考]]></title>
    <url>%2F2017%2F08%2F22%2F%E5%85%B3%E4%BA%8ENumpy%E9%80%9F%E5%BA%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[前言 对于 Python 语言，听到吐槽最多的就是速度了，因为 Python 执行代码的时候会执行很多的 ‘check’ 功能，比如：b=1；a=b/0.5 ，这个看似简单的运算，在计算机内部，b 首先要从一个整数 integer 转化成浮点数 float ，才能执行下一步。而做数据挖掘，机器学习或数据分析，用到最多的就是 Python 的科学计算库了，Numpy 就是其中常用的一个，它能把 Python 和高性能的 C 语言合并在一起，在我们调用 Numpy 的时候，其实调用了很多 C 语言，而不是纯 Python，而本文将对 Numpy 最近的思考做个小结。 #Numpy Array的数据结构 其实 Numpy 就是 C 的逻辑，创建存储容器 ‘Array’ 的时候是寻找内存上的一连串区域来存放，而Python存放的时候不是连续的区域，这使得Python在索引这个容器里的数据不是那么有效率。下图是来自 Why Python is Slow: Looking Under the Hood， 数据存储结构很好的证明了效率问题。 运用 Numpy 的时候，我们通常不是用一个一维 Array 来存放数据，而是用二维或者三维的块来存放。因为 Numpy 快速的矩阵相乘运算，能将乘法运算分配到计算机中的多个核，让运算并行，而并行运算大大加速了运算速度，这也是 Numpy 为什么受人喜欢的一个原因。其实不管是1D/2D/3D 的 Array，从根本上，它都是一个 1D array! 我们常用的 2D Array，在计算机内存里是存储在一个连续空间上的，而对于这个连续空间，我们如果创建 Array 的方式不同，在这个连续空间上的排列顺序也有不同。在 Numpy 中，创建 2D Array 的默认方式是 “C-type” 以 row 为主在内存中排列，而如果是 “Fortran” 的方式创建的，就是以 column 为主在内存中排列。 12col_array = np.zeros((5,5), order='C') # C-typerow_array = np.zeros((5,5), order='F') # Fortran #合并操作 当计算中涉及合并矩阵，不同形式的矩阵创建方式会影响时间。因为在 Numpy 中的矩阵合并等，都是发生在一维空间里，不是我们想象的二维空间中! 1234567891011121314151617181920a = np.zeros((200, 200), order='C')b = np.zeros((200, 200), order='F')N = 9999def f1(a): for _ in range(N): np.concatenate((a, a), axis=0)def f2(b): for _ in range(N): np.concatenate((b, b), axis=0)t0 = time.time()f1(a)t1 = time.time()f2(b)t2 = time.time()print((t1-t0)/N) # 2.8277459246168757e-05print((t2-t1)/N) # 2.8879836340262445e-05 从时间上看，相差不是很明显，这与计算机的配置有关，本人计算机配置为： 在另一台比较旧的电脑上测试同样的数据，所需时间为： 12print((t1-t0)/N) # 2.1623800439660055e-03print((t2-t1)/N) # 3.7443810003330046e-03 旧电脑配置为： 可见时间效率上相差还是比较明显的。row 为主的存储方式，如果在 row 的方向上合并矩阵，将会更快。根据 C 语言的存储结构，完成合并操作，在 1D array 中，直接再加一个 row 放在 1D array， 所以在上面的测试中， f1 速度要更快。 但是在以 column 为主的系统中，往 1D array 后面加 row 的规则变复杂了，消耗的时间也变长。如果以 axis=1 的方式合并，”F” 方式的 f2 将会比 “C” 方式的 f1 更好。 有时候犯懒会直接使用 np.stack 来代替 np.concatenate， 因为这样可以少写一点代码，不过使用上面的形式，通过上面的测试发现为了速度，推荐还是尽量使用 np.concatenate，所以在做操作前看自己要在哪个 axis 上的操作多，然后再创建合适于自己的矩阵形式 (“C-type”/“Fortran”)。 #copy慢 view快 在 Numpy 中，copy 和 view. copy 顾名思义，会将数据 copy 出来存放在内存中另一个地方，而 view 则是不 copy 数据，直接取源数据的索引部分。下图来自 Understanding SettingwithCopyWarning in pandas。 123456789a = np.arange(1, 7).reshape((3,2))a_view = a[:2]a_copy = a[:2].copy()a_copy[1,1] = 0print(a)a_view[1,1] = 0print(a) a_view 的东西全部都是 a 的东西，动 a_view 的任何地方，a 都会被动到，因为他们在内存中的位置是一模一样的，本质上就是自己，而 a_copy 则是将 a copy 了一份，然后把 a_copy 放在内存中的另外的地方，这样改变 a_copy，a 是不会被改变的。 #矩阵展平 有时候要把一个矩阵展平, 用到 np.flatten() 或者 np.ravel()， ravel 返回的是一个 view （如果用 ravel，需要 copy 的时候才会被 copy ，我想这个时候可能是把 ravel 里面 order 转换的时候，如 ‘C-type’ -&gt; ‘Fortran’）， 而 flatten 返回的总是一个 copy，所以相比于 flatten， ravel 速度更快。 #选择数据 选择数据的时候，常会用到 view 或者 copy 的形式，如果能用到 view 的，尽量用 view，避免 copy 数据。 使用 np.take(), 替代用 index 选数据的方法1234567891011a = np.random.rand(1000000, 10)N = 99indices = np.random.randint(0, 1000000, size=10000)def f1(a): for _ in range(N): _ = np.take(a, indices, axis=0)def f2(b): for _ in range(N): _ = b[indices] 使用 np.compress(), 替代用 mask 选数据的方法a_copy2 = a[[True, True], [False, True]] 这种就是用 TRUE， FALSE 来选择数据的 12345678mask = a[:, 0] &lt; 0.5def f1(a): for _ in range(N): _ = np.compress(mask, a, axis=0)def f2(b): for _ in range(N): _ = b[mask]]]></content>
      <categories>
        <category>Python库</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWS-EC2云服务器搭建VPN/SS服务]]></title>
    <url>%2F2017%2F08%2F15%2FAWS-EC2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAVPN%E4%B8%8ESS%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言 前段时间自己用的GreenVPN服务突然被告知被封了，无法提供翻墙服务了，日常查找一些资料需要FQ。之后我也尝试了很多方法，从最开始朋友给的vpn账号，到现在折腾亚马逊一年免费的ec2套餐自己搭建vpn/ss服务（没办法，生命不息，折腾不止），一来基本免费，二来可以自己动手搭建vpn/ss服务用起来相对更安全些。 开通amazon aws/ec2的教程网上很多，我这里就不详细写了，大家自行 google 吧，有几点需要注意的简单提一下： 去 https://aws.amazon.com/ 注册账号，你amazon.cn的账号并不能用； 需要有一张可用的信用卡，开通的过程中会需要扣你1美刀的预付款作为验证信用卡可用性，验证过程是电话验证，所以还要保持你的手机可用； 进入控制台之后，可能会纠结在哪个区申请ec2实例，可以去http://www.cloudping.info/ 测试你到哪个机房延迟比较低，一般来说东京延迟最低； 创建ec2的过程基本都是一路下一步，注意看清楚’free’标识就行； 保存好生成的密钥（PEM）文件，以后ssh要用到。 当你的一年免费ec2实例就申请好后，可以进行搭建vpn的操作了。 需注意:一年快到期前一定要取消这个服务，否则下一年就要收费了，并且亚马逊的服务还是很贵的，如果还想继续吃免费午餐的话重新注册一个新账号。 环境服务器：AWS-EC2 Ubuntu 16.04.2 LTS 本地：win10/64位 登录到ec2实例1ssh -i "/path/to/your/pem/file" ubuntu@your.ec2.instance.at.compute.amazonaws.com 我在本地采用xmanager工具的xshell的图形化界面，使用SSH协议建立连接后可以打开图像操作界面，远程登陆Ubuntu的终端。 搭建VPN服务VPN具有先天跨平台的优势，各类操作系统都有自己的VPN功能，直接可以用，无需第三方客户端。 但是VPN不够灵活，默认情况下，系统所有的流量都会从VPN走（很多VPN服务都可以设置全局变量或局部变量，即当设置成局部变量时，需要FQ时就会选用VPN服务，访问国内网站时就用本地网络，若是设置成全局变量，所有的流量都要从VPN走，这样有时候速度大打折扣），很多时候都是不必要的，比如你上个 youku，数据是从 youku 到东京机房，再从东京机房回到你的电脑，绕一大圈，不仅速度慢还浪费VPN流量。当然可以手动修改路由表，决定哪些流量走VPN哪些直连，但是这个工作量太大了。 不过VPN够全能，ssh/ss做不了的VPN全都没问题，比如你安装了twitter的客户端，ssh/ss就没办法帮你翻了，但是VPN没问题，所以，VPN服务还是选择安装了。 VPN包含PPTP,L2TP,OpenVPN,IPSec四种模式，这里选择安全性和实用性都还可以的PPTP模式。 安装 pptp 和防火墙1sudo apt-get install pptpd ufw 修改pptpd.conf默认配置1234sudo vim /etc/pptpd.conf#在最后添加，去掉注释localip 192.168.0.1 #主机ipremoteip 192.168.0.234-238,192.168.0.245 #分配的ip段 配置防火墙12345678# 允许SSHsudo ufw allow 22# 允许HTTPsudo ufw allow 80# 允许VPNsudo ufw allow 1723# 启用UFWsudo ufw enable 注意，需要允许SSH端口，不然无法用SSH登录服务器。 设置 VPN DNS1234sudo vim /etc/ppp/pptpd-options#添加，使用google dnsms-dns 8.8.8.8ms-dns 8.8.4.4 添加VPN账号123456sudo vim /etc/ppp/chap-secrets# Secrets for authentication using CHAP# client server secret IP addresses# 添加一行，依次为：用户名，服务，密码，限制ip：zou pptpd yourpassword * 设置ip转发12345sudo vim /etc/sysctl.conf# 打开注释net.ipv4.ip_forward=1# 使它立刻生效sudo sysctl -p 添加 iptables 规则1234567# 安装iptablessudo apt-get install iptables# 建立一个 NAT，开启iptables转发（其中eth0是联网网卡，192.168.0.1/24是准备使用的网段与第2步的主机ip）sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE# 将规则保存，使重启后规则不丢失sudo iptables-save &gt; /etc/iptables-rules 若此处提示：-bash: /etc/iptables-rules: Permission denied 则可使用root用户，命令： su - 进入root用户保存 编辑网卡文件，加载网卡时自动加载规则1234567sudo vim /etc/network/interfaces# 末尾加入pre-up iptables-restore &lt;/etc/iptables-rules# 设置MTU，防止包过大sudo iptables -A FORWARD -s 192.168.0.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1200# 若设置了上条规则，记得保存sudo iptables-save &gt;/etc/iptables-rules 修改防火墙UFW配置文件12vim /etc/default/ufw#将“DEFAULT_FORWARD_POLICY” 的值改为 “ACCEPT” macos 能连上，但没有任何收发包的问题，即能连接上VPN，不能上网：vpn高级里勾选发送全部流量 搭建SS服务在国内搜索技术文章，如果使用baidu的话，你懂的。因此就转向google，但是由于众所周知的原因，我们无法访问google，同样可以用AWS-EC2服务器搭建ShadowSocks服务器，然后就可以愉快的FQ进行科学上网。 ShadowSocks有如下特点： 快速（异步I/O和事件驱动程序）安全（所有的流量都经过加密算法加密，支持自定义算法）支持移动客户端（专为移动设备和无线网络优化）跨平台（可运行于包括PC，Mac，手机（Android和iOS）和路由器（OpenWrt）在内的多种平台上）开源、易于维护 安装ShadowSocksAWS服务器我选择的是Ubuntu系统。 前面的过程省略，我是直接使用xshell工具连上云服务器进行操作的。 123456# 先装pipsudo apt-get updatesudo apt-get install python-pip# 安装shadowsockssudo pip install shadowsockssudo apt-get -y install python-m2crypto 配置ShadowSocks安装完毕后，可以查看使用ssserver命令进行查看。如下： 1ssserver -h 添加配置并编辑 123456789101112sudo vim /etc/shadowsocks.json#加入如下配置&#123; "server":"0.0.0.0", "server_port":8388, #任意端口 "local_address":"127.0.0.1", "local_port":1080, "password":"你的密码", "timeout":1000, "method":"aes-256-cfb", "fast_open":false&#125; 输入完成后保存退出，然后启动服务 1ssserver -c /etc/shadowsocks.json start 安装客户端windows版本下载，下载完毕后，双击Shadowsocks.exe。 在弹出的窗口中，填入Shadowsocks服务器的IP、Shadowsocks服务器端口已经密码，就可以连接Shadowsocks服务器，如下： 正确连接Shadowsocks服务器后，我们就可以进行科学上网了。 注意 使用SS服务的时候，先要SSH连接EC2服务器，启动服务，然后，再打开客户端 暂停SS服务的时候，用命令 ssserver -c /etc/shadowsocks.json stop ，如果启动服务的时候显示socket.error: [Errno 98] Address already in use，则表示未正确关闭服务，端口仍被占用，此时用 1234#查看端口被占用的进程netstat -tunlp#关闭被占用进程kill 进程号]]></content>
      <categories>
        <category>VPN/SS服务搭建</category>
      </categories>
      <tags>
        <tag>AWS-EC2</tag>
        <tag>VPN</tag>
        <tag>SS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取需执行js的网页数据]]></title>
    <url>%2F2017%2F08%2F01%2FPython%E7%88%AC%E5%8F%96js%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言 一般情况下，对静态网页我一般采用”requests + BeautifulSoup + re”这三个库，可以解决大部分爬虫问题，如果工程量较大，一般会采用Scrapy框架处理爬虫，但有些网页是在加载时动态创建HTML内容，只有在js代码完全执行完后才会显示最终结果。如果用传统的方法抓取页面，就只能获得js代码执行之前页面上的内容，一般要解决这个问题有两种方法： 1.直接分析接口，从js代码中抓取数据（执行js代码，解析js变量，不需要解析html）。 2.用第三方库运行js，抓取运行后的最终html页面。 所以对于通过Ajax、JavaScript等动态加载的网页，就需要通过”Phantomjs + CasperJS + Selenium”来实现了。本文解决的是在工作中遇到的一个小问题，即遇到需要执行页面上JavaScript才能爬取数据的网页，在分析问题后发现可以用两种方法解决该问题，一种是用提交表单数据的post方法来获取所需数据，另一种用 Selenium 和 Phantomjs处理js加载的动态数据。 问题抓取大连商品交易所期货行情的一个月的日行情数据，大连商品交易所。 问题分析对于该问题，在分析后我采用两种方法来解决。 常规方法，Requests + BeautifulSoup 用Selenium 和 Phantomjs处理需加载js的动态数据 Requests + BeautifulSoup在选定查询日期后，品种选全部之后，点击查询进行抓包分析后，发现结果页面跳转到新的页面“http://218.25.154.81/PublicWeb/MainServlet”，并对页面分析发现结果为post方式，所以找到发送的form表单数据，查看是否能得到结果。 123456import requestsurl = "http://218.25.154.81/PublicWeb/MainServlet"postdata =&#123;"action":"Pu00011_result","Pu00011_Input.trade_date":"20170801","Pu00011_Input.variety":"all","Pu00011_Input.trade_type":"0","Submit":"%B2%E9+%D1%AF"&#125;r = requests.post(url,data = postdata)print(r.text) 却发现输出的为： 1&lt;script type="text/javascript"&gt;alert('输入项包含非法字符！');window.history.back();&lt;/script&gt; 抓包分析发现post的数据输入项包含非法字符！，此时submit键值包含非法字符，当提交表单时，会发生 submit 事件，所以把它当成默认就好，再次执行以上代码，发现可以返回查询数据。 123456import requestsurl = "http://218.25.154.81/PublicWeb/MainServlet"postdata =&#123;"action":"Pu00011_result","Pu00011_Input.trade_date":"20170801","Pu00011_Input.variety":"all","Pu00011_Input.trade_type":"0"&#125;r = requests.post(url,data = postdata)print(r.text) 对于大连交易所日行情数据的抓包分析，常规方法可以通过requests的post方式发送json数据来获取所需数据，通过当月贸易日期构造循环来发送表单获取数据。 用Selenium 和 Phantomjs处理需加载js的动态数据当我用requests.get()方法获取数据时，返回的信息并没有找到对应的元素，进行抓包分析，发现页面动态加载了js，于是，我采用了Phantomjs+Selenium的方式获取这一类数据，但在后续的分析中发现，本页面同时使用了frame框架，使用Phantomjs+Selenium后并不会加载iframe框架中网页内容（iframe框架相当于在页面中又加载了一个页面），需要使用Selenium的swtch_to.frame()方法加载或者直接请求框架里的页面（即本问题中的http://218.25.154.81/PublicWeb/MainServlet?action=Pu00011_search）。 123456import requestsurl = "http://218.25.154.81/PublicWeb/MainServlet?action=Pu00011_search"headers = &#123;"user-agent":"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5"&#125;r = requests.get(url,headers = header)print(r.text) 页面仍然需要加载js才能显示，所以还是需要用 Phantomjs + Selenium 来处理，接下来先做环境配置。 本地环境Windows 10 / 64位 Python 3.6.0 Selenium简介selenium是一个用于Web应用自动化程序测试的工具，测试直接运行在浏览器中，就像真正的用户在操作一样 selenium2支持通过驱动真实浏览器（FirfoxDriver，IternetExplorerDriver，OperaDriver，ChromeDriver） selenium2支持通过驱动无界面浏览器（HtmlUnit，PhantomJs） 安装可以直接在自己的pip安装目录下输入命令安装 1pip install -U selenium Phantomjs简介PhantomJS 是一个基于 WebKit（WebKit是一个开源的浏览器引擎，Chrome，Safari就是用的这个浏览器引擎） 的服务器端 JavaScript API，即基于webkit的没有界面的浏览器。 主要应用场景是：无需浏览器的 Web 测试，页面访问自动化，屏幕捕获，网络监控 安装下载源码安装，下载地址。 解压并把解压缩的路径D:\Python\phantomjs-2.1.1-windows\bin\添加到环境变量中即可。 Python 可以使用 Selenium 执行 javascript ，Selenium 可以让浏览器自动加载页面，获取需要的数据。Selenium 自己不带浏览器，可以使用第三方浏览器如Firefox，Chrome等，也可以使用headless浏览器如PhantomJS在后台执行。 首先，在一般的浏览器都是像Chrome、Firefox之类的有图形界面的，但是这种GUI浏览器其实执行效率比较慢，因为要渲染出图形来，那么无GUI的浏览器的优势就有了，无GUI意味着占用资源少了，执行效率快，而爬虫中如果是选择了模拟浏览器的方式来做页面请求，那么把GUI的浏览器换成无GUI的浏览器是可以在一定程度上提高爬虫速度，减少资源消耗的，所以本例中也选择了Selenium + Phantomjs 的方式处理爬虫。 Selenium + PhantomJS 安装测试123456from selenium import webdriver driver = webdriver.PhantomJS(executable_path=r"D:\Python\phantomjs-2.1.1-windows\bin\phantomjs.exe") driver.get("http://www.baidu.com") data = driver.titledriver.save_screenshot('baidu.png') print(data) 如果输出的结果为： 1百度一下，你就知道 同时，在默认目录下生成百度的截图，则说明配置完成，接下来可以抓取页面了。 问题解决Requests + BeautifulSoup详细代码如下，代码未做较好的优化，大神勿喷。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import requestsfrom bs4 import BeautifulSoupfrom acmr.PriceCollection.user_agent import USER_AGENTSimport randomimport xlwt# 日期转化函数，将日期转化为'20170701'的格式def trade_date(year,month): if month in range(1,13): date = [] if month in [1,3,5,7,8,10,12]: for day in range(1,32): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year,month,day) date.append(temp_date) elif month in [4,6,9,11]: for day in range(1,31): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year, month, day) date.append(temp_date) else: if year%4 == 0: for day in range(1, 30): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year, month, day) date.append(temp_date) else: for day in range(1, 29): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year, month, day) date.append(temp_date) return date else: print("月份输入错误！")# 获取html源码def get_html(url,postdata): header = &#123;"user-agent":random.choice(USER_AGENTS)&#125; r = requests.post(url,data=postdata,headers = header) html = r.text.encode("GB2312").decode("GB18030") return html# 解析html源码，抓取所需数据def parse_html(html): soup = BeautifulSoup(html,"html.parser") table = [] if soup.find("p").get_text() == '': print("工作日！") title = soup.find_all("div")[0].get_text() title2 = soup.find_all("div")[1].get_text() table.append([title]) table.append([title2.replace("\xa0"," ")]) trs = soup.find("table",class_ = "table").find_all("tr") for tr in trs: td =[td.get_text().replace("\xa0","") for td in tr.find_all("td")] table.append(td) else: print(soup.find("p").get_text()) return table# 写入excel，写成xls格式def write_xls(table,date): file = xlwt.Workbook(encoding='utf-8') # 指定file以utf-8的格式打开 sheet = file.add_sheet(date) for i, p in enumerate(table): for j, q in enumerate(p): sheet.write(i, j, q) file.save(r'D:\Python\ProjectPy3\acmr\PriceCollection\DLCE\xls\&#123;&#125;.xls'.format(date))if __name__ == "__main__": ''' 1.修改url 2.修改日期 ''' url = "http://218.25.154.81/PublicWeb/MainServlet" for date in trade_date(2017,7): postdata = &#123; "action": "Pu00011_result", "Pu00011_Input.trade_date":date, "Pu00011_Input.variety": "all", "Pu00011_Input.trade_type": "0"&#125; html = get_html(url,postdata) table = parse_html(html) write_xls(table,date) 用Selenium 和 Phantomjs处理需加载js的动态数据单日数据获取测试代码本代码可以选用谷歌浏览器或者火狐浏览器进行测试，也可以选用Phantomjs无头浏览器， 123456789101112131415161718192021222324252627282930313233import requestsimport time,randomfrom selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesdcap = dict(DesiredCapabilities.PHANTOMJS)header = ("Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5")dcap["phantomjs.page.settings.User-Agent"] = headerdriver = webdriver.PhantomJS(executable_path=r"D:\Python\phantomjs-2.1.1-windows\bin\phantomjs.exe",desired_capabilities=dcap) url = "http://218.25.154.81/PublicWeb/MainServlet?action=Pu00011_search"driver.set_page_load_timeout(5)driver.implicitly_wait(10)driver.get(url)input = driver.find_element_by_xpath('//input[@name="Pu00011_Input.trade_date"]')input.clear()input.send_keys("20170704")driver.find_element_by_xpath('//input[@value="查 询"]').click()#获取当前窗口句柄now_handle = driver.current_window_handleprint(now_handle)# 获取全部窗口句柄all_handles = driver.window_handlesfor handle in all_handles: if handle !=now_handle: #输出待选择的窗口句柄 print(handle) driver.switch_to_window(handle) title = driver.find_element_by_xpath('//div[@class="title"]').text title2 = driver.find_element_by_xpath('//div[@class="title2"]').text print(title,"---",title2)#driver.save_screenshot("1.png")driver.switch_to_window(now_handle)driver.quit() 单日数据爬取成功后在进行整个月的数据爬取，完整的代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import time,randomfrom bs4 import BeautifulSoupfrom acmr.PriceCollection.user_agent import USER_AGENTSfrom selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesfrom selenium.common.exceptions import TimeoutExceptionimport xlwt# 日期转化函数，将日期转化为'20170701'的格式def trade_date(year,month): if month in range(1,13): date = [] if month in [1,3,5,7,8,10,12]: for day in range(1,32): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year,month,day) date.append(temp_date) elif month in [4,6,9,11]: for day in range(1,31): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year, month, day) date.append(temp_date) else: if year%4 == 0: for day in range(1, 30): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year, month, day) date.append(temp_date) else: for day in range(1, 29): temp_date = "&#123;:04&#125;&#123;:02&#125;&#123;:02&#125;".format(year, month, day) date.append(temp_date) return date else: print("月份输入错误！")# 解析html源码，抓取所需数据def parse_html(html): soup = BeautifulSoup(html,"html.parser") table = [] if soup.find("p").get_text() == '': print("工作日！") title = soup.find_all("div")[0].get_text() title2 = soup.find_all("div")[1].get_text() table.append([title]) table.append([title2.replace("\xa0"," ")]) trs = soup.find("table",class_ = "table").find_all("tr") for tr in trs: td =[td.get_text().replace("\xa0","") for td in tr.find_all("td")] table.append(td) else: print(soup.find("p").get_text()) return table# 写入excel，写成xls格式def write_xls(table,date): file = xlwt.Workbook(encoding='utf-8') # 指定file以utf-8的格式打开 sheet = file.add_sheet(date) for i, p in enumerate(table): for j, q in enumerate(p): sheet.write(i, j, q) file.save(r'D:\Python\ProjectPy3\acmr\PriceCollection\DLCE\xls\&#123;&#125;.xls'.format(date))# 获取数据写入exceldef get_data(browser,url,dates): browser.get(url) # 获取当前窗口句柄 now_handle = browser.current_window_handle print(now_handle) for date in dates: try: input = browser.find_element_by_xpath('//input[@name="Pu00011_Input.trade_date"]') input.clear() input.send_keys(date) browser.find_element_by_xpath('//input[@value="查 询"]').click() # time.sleep(5) except TimeoutException: print("Click failed: timeout") # 获取全部窗口句柄 all_handles = browser.window_handles for handle in all_handles: if handle != now_handle: #输出待选择的窗口句柄 print(handle) browser.switch_to_window(handle) # time.sleep(5) if browser.find_element_by_xpath('//p[@align="center"]').text: print(browser.find_element_by_xpath('//p[@align="center"]').text) else: title = browser.find_element_by_xpath('//div[@class="title"]').text title2 = browser.find_element_by_xpath('//div[@class="title2"]').text print(title, "---", title2) html = browser.page_source.encode("GB2312").decode("GB18030") table = parse_html(html) write_xls(table,date) browser.close() # 关闭当前窗口，当出现异常时在任务浏览器中关闭PhantomJS，因为会有多个PhantomJS在运行状态，影响电脑性能 browser.switch_to_window(now_handle) browser.quit() #关闭浏览器。当出现异常时记得在任务浏览器中关闭PhantomJS，因为会有多个PhantomJS在运行状态，影响电脑性能Lif __name__ == "__main__": url = "http://218.25.154.81/PublicWeb/MainServlet?action=Pu00011_search" dcap = dict(DesiredCapabilities.PHANTOMJS) # 从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器 dcap["phantomjs.page.settings.User-Agent"] = (random.choice(USER_AGENTS)) browser = webdriver.PhantomJS(executable_path=r"D:\Python\phantomjs-2.1.1-windows\bin\phantomjs.exe",desired_capabilities=dcap) # 设置全屏,调用启动的浏览器不是全屏的，有时候会影响某些操作 browser.maximize_window() # 设置页面完全加载的超时时间，完全加载即完全渲染完成，同步和异步脚本都执行完 browser.set_page_load_timeout(10) # 隐性等待设置为10秒 browser.implicitly_wait(10) dates = trade_date(2017, 7) get_data(browser,url,dates) 总结 对于该问题，用requests库的post方法速度快，因为不需要js的加载，渲染等，并且大连商品交易所网站打开速度较慢，在用Selenium 和 Phantomjs方法获取数据的时候需设置好浏览器的渲染所需的时间，更适合选用常规方法。 选用Selenium 和 Phantomjs方法解析html获取数据的时候，也采用了BeautifulSoup库，因为方法1已经写好解析html的方法，虽然用selenium的xpath方法也可以获取，但是这样无疑增加工作量，直接用方法1的接口，提高代码的复用率。 由于时间有限，这两个方法均未进行良好的优化，可能有些功能不够简洁，所以之后有时间再来进行代码的回顾，将方法重构的更完善。]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
        <tag>Phantomjs</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github 搭建静态博客]]></title>
    <url>%2F2017%2F07%2F25%2FHexo%20%2B%20Github%20%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 最近用 Python 的 Pelican 搭建了自己的静态博客，效果预览（目前已迁移到hexo）。在用 Pelican 搭建博客的过程中几乎 Pelican 支持的主题都试过，都没什么让自己满意的，最后才勉强选了个看的过去的主题，但是当我看到 Hexo 搭建的博客系统的时候，瞬间觉得 Hexo 的 NexT 主题简洁又大方，很喜欢，所以打算继续折腾下，顺便简单了解下 Node.js 的静态博客框架。 Hexo 简介Hexo 出自台湾大学生tommy351之手,是由Node.js驱动的一款快速、简单且功能强大的博客框架。Node.js是一个可以快速构建网络服务及应用的平台，该平台的构建是基于Chrome’s JavaScript runtime，也就是说，实际上它是对Google V8引擎（应用于Google Chrome浏览器)进行了封装，而 V8 引擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。 环境配置本地环境 Windows 10/64位 安装 Git Bash 下载地址 双击下载好的exe文件，一路 Next就行 安装好后，打开Git Bash，用命令git version查看版本 1git version 安装 Node.js 下载地址(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：msi文件下载完成后，双击打开安装，一直 Next（注意：在Custom Setup这一步记得选 Add to PATH ,这样就不需要自己去配置环境变量），安装完成后打开 cmd ，在 cmd 中输入 path 可以看到你的 node 是否配置到环境变量里，如果没有，手动添加到环境变量。 查看版本 ： 在 cmd 中输入命令 node -v 安装 Hexo 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令： 1npm instal -g hexo （`-g`表示全局安装, `npm`默认为当前项目安装） node.js 和 git 安装好后，建议使用 git 提供的命令行窗口进行操作，windows自带的cmd会报错。 安装完成后，查看版本：hexo -v 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件 1234567891011Nodejs-blog/├── node_modul # 依赖包目录，包含各类生成器/渲染器/服务器等├── public # 在运行hexo g和hexo s 后生成的静态页面目录├── scaffolds # 命令生成文章等的模板的目录├── source # 用命令创建的各种文章的目录| ├── _drafts # 草稿（后期通过命令生成）| └── _posts # 文章├── themes # 主题目录├── _config.yml # 整个博客的配置文件├── db.json # source解析所得到的文件└── package.json # 项目所需模块项目的配置信息文件 必备插件，建议一起安装（一般已在依赖包里自动生成，如果没有可执行以下命令） 12345678npm install hexo-generator-index --save # 索引生成器npm install hexo-generator-archive --save # 归档生成器npm install hexo-generator-category --save # 分类生成器npm install hexo-generator-tag --save # 标签生成器npm install hexo-server --save # 本地服务npm install hexo-deployer-git --save # hexo通过git发布（必装）npm install hexo-renderer-marked@0.2.7--save # 渲染器npm install hexo-renderer-stylus@0.3.0 --save # 渲染器 测试是否配置成功 生成静态页面，cd至之前初始化的目录，执行如下命令，即可生成静态页面至public目录 1hexo g 启动本地服务，进行预览（必须安装hexo server） 1hexo s 浏览器输入 localhost:4000 即可访问默认的 Hexo 博客效果。如果没有报错则表示 Hexo 基本配置安装成功，可进行自定义定制。 如果访问 http://localhost:4000/ 无反应，可能由于默认端口被占用引起的。使用 Ctrl+C 中断本地服务，使用命令自定义端口 hexo s -p 5000 重新开启本地服务，访问 http://localhost:5000/ 可以看到博客页面了。 常用命令 1234567hexo new "postName" # 新建文章hexo new page "pageName" # 新建页面hexo generate # 生成静态页面至public目录hexo server # 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy # 将.deploy目录部署到GitHubhexo help # 查看帮助hexo version # 查看Hexo的版本 123hexo 组合命令hexo clean &amp;&amp; hexo g -s # 清除、生成、启动hexo clean &amp;&amp; hexo g -d # 清除、生成、部署 12345hexo 命令缩写hexo g：hexo generatehexo c：hexo cleanhexo s：hexo serverhexo d：hexo deploy 安装主题NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下，可参考NexT。 下载主题如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 12cd your-hexo-site # 进入自己的blog目录git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题当 克隆/下载 完成后，打开站点配置文件 _config.yml， 找到 theme 字段，并将其值更改为 next。 验证主题NexT 主题安装完成后将验证主题是否正确启用。首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug）。 12hexo clean # 来清除 Hexo 的缓存hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行，打开后是 NexT 默认的 Scheme —— Muse。 主题设定在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题themes目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 1234# Schemesscheme: Muse#scheme: Mist#scheme: Pisces 设置语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 网站logo设置 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。 next主题：将图片放在站点source目录下新建 images文件夹 在next 主题配置文件中修改： 1favicon: /images/favicon.ico 修改网站相关信息编辑 站点配置文件： 1234567# Sitetitle: 心安即行 自在欢喜 # 网站titlesubtitle: 一生所求 爱与自由 你与温柔 # 副标题，网站名下面描述description: 数据科学、数据挖掘分析博客 # 网站描述，便于搜索引擎用关键词检索，也可以是自己喜欢的签名author: Joshua Zou # 网站作者昵称language: zh-Hanstimezone: Asia/Shanghai 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 1since: 2016 设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下图标模糊的问题。 编辑 主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 12345678menu: home: / archives: /archives about: /about categories: /categories tags: /tags #commonweal: /404.html search: /search 置菜单项的显示文本。 在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 life。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 life: 生活日志 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 12345678910menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat search: search 添加「标签」「分类」「关于」页面 新建页面 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： 12cd your-hexo-sitehexo new page tags 设置页面类型 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 123456---title: 标签/分类date: 2014-12-22 12:39:04type: "tags"/"categories"comments: false--- 注意：如果有启用 多说 或者 Disqus 评论，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false. 修改菜单 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: 12345menu: home: / archives: /archives categories: /categories tags: /tags 腾讯公益 404 页面source 目录下新建 404.html 页面 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="your-site-url" homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置 12sidebar: position: right 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 12sidebar: display: post 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。 1234567# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称，匹配键与上一步所配置的链接的显示文本相同（大小写严格匹配），图标名称是Font Awesome 图标的名字（不必带 fa- 前缀）。enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 12345678# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 知乎: user-circle 友情链接编辑 主题配置文件 添加： 1234# Blog rollslinks_title: Linkslinks: WC: https://weichangit.github.io/ 设置头像编辑 站点配置文件， 修改字段 avatar 值设置成头像的链接地址。其中，头像的链接地址可以是： 完整的互联网 URI: http://example.com/avatar.jpg 站点内的地址 将头像放置站点目录下的 source/uploads/ （新建uploads目录若不存在）配置为： 1avatar: /uploads/avatar.jpg 或者放置在主题目录下 source/images/ 目录下配置为： 1avatar: /images/avatar.jpg 优化主题 sidebar 头像为自己的头像添加旋转效果。 修改 /themes/next/source/css/_common/components/sidebar/sidebar-author.styl 文件，在.site-author-image {}内后面添加如下代码。（要保证自己的头像，也就是 avatar.jpg 这个图片是正方形，不是的话你要将其修改成正方形，这样才能通过样式将其展现为很好看的正圆，否则会是一个椭圆形） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125; 给博客添加LICENSE在主题配置文件中添加下面这段代码（添加之前好好看看你的主题配置文件是否已经包含这段代码，已经包含就不用再加一遍了，因为重复会报错），这个LICENSE显示在侧边栏。 12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 设置 RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 1npm install hexo-generator-feed --save 具体的链接地址：适用于已经烧制过 Feed 的情形 添加听音乐代码设置在 \themes\next\layout\_macro 目录下新建 high.swig 文件，添加以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;a title="收藏到书签，偶尔Relax一下!" rel="alternate" class="mw-harlem_shake_slow wobble shake" href='javascript:( /* * Copyright (C) 2015 Rocko (rocko.xyz) &lt;rocko.zxp@gmail.com&gt; * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ function go() &#123; var songs = [ "http://otr5y24lm.bkt.clouddn.com/music/blog/Josh%20Vietti%20-%20Where%20Is%20the%20Love.mp3", "http://otr5y24lm.bkt.clouddn.com/music/blog/TRON%20-%20%E4%B8%80%E7%94%9F%E6%89%80%E7%88%B1%EF%BC%88Cover%20%E5%8D%A2%E5%86%A0%E5%BB%B7%EF%BC%89.mp3", "http://otr5y24lm.bkt.clouddn.com/music/blog/Bobby%20Tinsley%20-%20Missing%20You.mp3", "http://otr5y24lm.bkt.clouddn.com/music/blog/%E9%9F%A9%E7%BA%A2%20-%20%E4%B8%80%E4%B8%AA%E4%BA%BA.mp3" "......" ]; function S() &#123; var e = document.getElementById("audio_element_id"); if(e != null)&#123; var index = parseInt(e.getAttribute("curSongIndex")); if(index &gt; songs.length - 2) &#123; index = 0; &#125; else &#123; index++; &#125; e.setAttribute("curSongIndex", index); &#125; e.src = i; e.play() &#125; function initAudioEle() &#123; var e = document.getElementById("audio_element_id"); if(e === null)&#123; e = document.createElement("audio"); e.setAttribute("curSongIndex", 0); e.id = "audio_element_id"; e.loop = false; e.bgcolor = 0; e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.addEventListener("ended", function() &#123; go(); &#125;, true); &#125; &#125; initAudioEle(); var curSongIndex = parseInt(document.getElementById("audio_element_id").getAttribute("curSongIndex")); var i = songs[curSongIndex]; S(); &#125;)()'&gt; &lt;i class="fa fa-music"&gt;&lt;/i&gt; 听音乐&lt;/a&gt; 在侧边栏引用该文件： 修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码： 1&#123;% include 'high.swig' %&#125; 样式修改： 使 听音乐 和 RSS 并排展示，修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl 文件(我选的Muse这个样式，默认并排展示)： 1display: inline-block; 音乐链接获取直接打开 网易云音乐网页版 搜索自己喜欢的音乐，下载下来上传到自己的服务器，我的放在七牛云上，自己注册后有一定的免费的空间，可以放图片、音乐等，这样在别人访问自己的博客的时候可以加快速度。 在high.swig文件中添加自己喜欢的音乐： 1234567var songs = [ "http://otr5y24lm.bkt.clouddn.com/music/blog/Josh%20Vietti%20-%20Where%20Is%20the%20Love.mp3", "http://otr5y24lm.bkt.clouddn.com/music/blog/TRON%20-%20%E4%B8%80%E7%94%9F%E6%89%80%E7%88%B1%EF%BC%88Cover%20%E5%8D%A2%E5%86%A0%E5%BB%B7%EF%BC%89.mp3", "http://otr5y24lm.bkt.clouddn.com/music/blog/Bobby%20Tinsley%20-%20Missing%20You.mp3", "http://otr5y24lm.bkt.clouddn.com/music/blog/%E9%9F%A9%E7%BA%A2%20-%20%E4%B8%80%E4%B8%AA%E4%BA%BA.mp3" "......" ]; 首页听音乐摇晃： 需要加载 css 样式，在 themes\next\layout\_layout.swig 文件的 &lt;/body&gt; 标签前添加以下代码： 12&lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意：有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stly 文件即可解决。 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址即可开启该功能。 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 首页分割线在 \themes\next\source\css\_custom\custom.styl 文件中添加以下代码，可以修改博客首页中每篇文章的分割线长度，我设置为了100%长度。 1234567891011//index页面中每篇文章相隔的那条线.posts-expand &#123; .post-eof &#123; display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 100%; height: 3px; background: $grey-light; text-align: center; &#125;&#125; 为博客加入动态背景首先找到\themes\next\layout\_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 1&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在 themes\source\js\src 下新建文件 particle.js 写上以下代码: 1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties。更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题。 修改超链接颜色打开\themes\next\source\css\ _variables\base.styl文件，像下面这样改掉这几行： 12345// Global link color.$link-color = $my-link-blue$link-hover-color = $my-link-hover-blue$link-decoration-color = $gray-lighter$link-decoration-hover-color = $my-link-hover-blue 集成常用的第三方服务Local Search添加百度/谷歌/本地 自定义站点内容搜索。 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 阅读次数统计（LeanCloud） 配置LeanCloud： 在注册完成 LeanCloud 帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到AppID以及AppKey这两个参数即可正常使用文章阅读量统计的功能了。 1控制台 =&gt; 创建应用 =&gt; 创建class [Counter,无限制]=&gt; 设置 =&gt; 应用Key [AppID,AppKey] 复制AppID以及AppKey并在主题配置文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 将阅读量改为热度（更个性）看到好多人的博客不是阅读次数（阅读量），而是xxx度，那么可以继续这样修改，首先在Next主题的/themes/next/languages/zh-Hans文件中查找”阅读次数“这几个字，可以看到，在post中的visitors被定义为“阅读次数”，把这里的“阅读次数”改为“热度”。 打开 Next主题文件夹中layout/_macro/post.swig，在这个文件里加上摄氏度的标志，在&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;下面增加一行&lt;span&gt;℃&lt;/span&gt;即可。 不蒜子统计 全局配置 编辑主题配置文件 中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 站点UV配置 site_uv: true时，代表在页面底部显示站点的UV值。 site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 1234# 效果：本站访客数12345人次site_uv: truesite_uv_header: &lt;i class="fa fa-user"&gt;本站访客数&lt;/i&gt;site_uv_footer: 人次 站点PV配置 当site_pv: true时，代表在页面底部显示站点的PV值。 site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 1234# 效果：本站总访问量12345次site_pv: truesite_pv_header: &lt;i class="fa fa-eye"&gt;本站总访问量&lt;/i&gt;site_pv_footer: 次 单页PV配置 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 1234# 效果：本文总阅读量12345次page_pv: truepage_pv_header: &lt;i class="fa fa-file-o"&gt;本文总阅读量/热度&lt;/i&gt;page_pv_footer: 次/℃ 单页PV配置可以和LeanCloud阅读次数选择其一。 添加 sitemap插件安装谷歌与百度的站点地图，前者适用于其他搜索引擎，用来手动提交以增加收录。使用以下命令来安装针对百度和Google的地图插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 配置站点配置文件配置站点配置文件_config.yml，启用相应插件 123Plugins:- hexo-generator-sitemap- hexo-generator-baidu-sitemap 配置站点地图文件 12345#sitemapsitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 配置成功后，hexo g编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml。其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。其次，在站点根目录下新建一个robots.txt文件，其中添加下面的一段代码（具体网站改为你自己的网址）： 123456789101112# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://www.joshuazou.cn/sitemap.xmlSitemap: https://www.joshuazou.cn/sitemap.xml 我们在百度里面搜索site:joshuazou.cn，发现没有我们的博客并没有被百度收录，也就是说你的博客别人可能会看不到，下面来解决这个问题： 进入链接提交，然后验证网站所有权，有三种方式可以选择，一般选择文件验证，下载baidu_verify_qzE3XIJ4hj.html文件到source/目录下面，修改站点配置文件。 123skip_render: - README.md - baidu_verify_qzE3XIJ4hj.html 但是，我经过多次验证总是失败，所以最终选择CNAME验证，详细步骤。按照说明完成验证，在百度站长平台里面的站点管理里面看到是否验证成功。 上面进行步骤成功之后，进入站点信息-&gt;网页抓取-&gt;链接提交-&gt;详情，按照说明进行设置。因为Github主机禁止百度爬虫访问博客，导致博客无法被百度收录，而使用google的话就能搜索到github搭建的博客，所以我尝试了多种解决百度收录Github的方案，最终推荐采用百度站长工具，弥补百度蜘蛛无法抓取的不足，因此推荐自动推送。 从效率上来说： 主动推送&gt;自动推送&gt;sitemap 设置自动推送 安装自动推送插件，在根目录下执行 1npm install hexo-baidu-url-submit --save 主题配置文件下设置,将baidu_push设置为true： 1baidu_push: true 修改`站点配置文件` 12345baidu_url_submit:count: 3 ## 比如3，代表提交最新的三个链接host: your web host ## 在百度站长平台中注册的域名token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里!path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 在`站点配置文件`中加入新的部署 12345deploy: - type: git repo: github: xxxxxxxx - type: baidu_url_submitter 执行`hexo deploy`的时候，新的链接就会被推送了。 完成后可能需要等一段时间，在百度里面搜索site:joshuazou.cn，有记录说明是被收录了。 类似百度，通过HTML文件方式验证通过后，在站点里选择 抓取-&gt;站点地图里 添加/测试站点地图。完成后等一段时间（大概一天时间）在Google里面搜索site:joshuazou.cn，就可以看到搜索结果了。 页脚加入地图在页脚加入百度地图和谷歌地图链接： 找到\themes\next\layout\_partials\footer.swig文件，百度和Google网站地图，上面已经安装了，这是插入到底栏的代码： 12&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;span&gt;&lt;a href="/sitemap.xml"&gt;Google网站地图&lt;/a&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;span&gt;&lt;a href="/baidusitemap.xml"&gt;百度网站地图&lt;/a&gt;&lt;/span&gt; 增加留言页在你的站点文件夹，用Git Bash等运行下面这行代码： 1hexo new page "guestbook" 找到主题配置文件，文件路径\themes\next\_config.yml，添加guestbook到menu中，如下: 12345678menu: home: / #categories: /categories about: /about archives: /archives # tags: /tags #commonweal: /404.html guestbook: /guestbook 并将图标添加到menu_icons： 1234menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome guestbook: file-text 找到你Next主题zh-Hans.yml文件，文件路径\themes\next\languages\zh-Hans.yml，添加guestbook: 留言板到menu中，如下: 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 guestbook: 留言 添加友言评论系统注册友言得到自己的uid，并在主题配置文件里设置： 1youyan_uid: your-uid 文章配图在标题和摘要中间，插进一张Logo图片，而当点击进入后，就不会再显示这个logo图片了。 css样式123hexo/themes/next/source/css/: 是next主题的样式文件，决定主题的外观。hexo/themes/next/source/css/main.styl：汇总css文件夹中所有的样式。hexo/themes/next/source/css/ _custom/custom.styl：是空的，专门让开发者扩展。 需要在custom.styl里为图片设计一个专用容器。 12345678910111213141516//图片外部的容器方框.out-img-topic &#123; display: block; max-height:300px; margin-bottom: 24px; overflow: hidden;&#125;//图片img.img-topic &#123; display: block ; margin-left: .7em; margin-right: .7em; padding: 0; float: right; clear: right;&#125; 这里图片外部的容器用来限制图片显示的大小，最大的高度为300px， overflow: hidden：让多余部分隐藏。 margin-bottom: 24px：确保图片和文章摘要部分空出一定空间。 渲染修改 /themes/next/layout/ _macro/post.swig ，在 if is_index 与 if post.description and theme.excerpt_description 之间添加以下代码 12345&#123;% if post.images %&#125; &lt;div class="out-img-topic"&gt; &lt;img src=&#123;&#123; post.images &#125;&#125; class="img-topic"&gt; &lt;/div&gt;&#123;% endif %&#125; 模板在 /scaffolds/post.md ，加一个images字段，那么在创建新的文章时，填的图片地址就会一直作为文章的一个属性被传递。 12345title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:images: 部署博客个人域名设置国内国外有很多的域名供应商，选择一个好的机构购买域名，会为自己的站点配置节约很多时间，也不会因为域名的出错，导致影响百度对我们个人博客的收录。近几年来，国内做的比较好的域名供应商有阿里的万网。我就是在阿里的万网购买的域名。通过查找，找到自己喜欢的域名。 登录进入万网的域名控制台，点击”域名和网站”中的”云DNS” 点击对应域名的”解析”，点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是joshuazou.cn。 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：joshuazou.cn。实践证明如果此时你填写的是www.joshua.cn那么以后你只能用www.joshua.cn访问，而如果填写的是joshua.cn。那么用www.joshua.cn和joshua.cn访问都是可以的。 重新清理hexo,并发布即可用新的域名访问。 发布文章到Github如需调试，可在Git Bush中输入 1hexo s --debug 然后在localhost:4000中进行调试，修改后刷新浏览器，即可看到配置后的样式。 调试完成后，可以用以下命令发布： 12hexo cleanhexo d -g 这样，就可以在自己的域名看到自己搭建的博客了，进入围观。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将本地项目上传到Github]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[前言 将自己新建的本地项目上传到 Github ，包括本地 Git 仓库设置及远程仓库 Github 设置。本次操作需要用到管理工具Git，点击下载。 本地Git仓库设置 创建Git配置文件。 通过命令git init把即将要上传的本地项目文件夹变成Git可管理的仓库，即创建该项目的本地版本库。你会发现你的文件下生成一个.git文件夹，默认是隐藏文件。可通过git status来查看你当前的状态。Git安装好之后，打开所要上传的项目文件夹，鼠标右键点击windows系统下选择Git Bash Here。 12$ git init$ git status 通过git add .（.和add之间有空格）将当前所有文件添加到仓库上，仍可通过git status来查看你当前的状态。 12$ git add .$ git status 用git commit把项目提交到仓库，-m后面引号里面是本次提交的注释内容，这个可以不写，但最好写上，不然会报错，详情自行Google。 1$ git commit -m "commit blog" 本地Git仓库这边的工作做完了，下面就到了连接远程仓库（也就是连接Github） 远程仓库Github设置本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下，先在本地生成一.ssh。 创建SSH KEY，先查看本地是否有.ssh文件，有的话删掉。 1$ cd ~/.ssh 输入命令，生成.ssh，写你自己的邮箱。 1$ ssh-keygen -t rsa -C "your email@.com" 一直回车就可以，这样就表示成功了，会在C盘的用户目录的根目录下生成一个.ssh文件，如果找不到，可以搜索一下，文件下会有id_rsa与id_rsa.pug两个文件。 本地目录下生成的文件： 为了避免与Github创建连接时出错，可以新建一个config文件，将以下代码复制进去： 123456Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 登录Github，找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。 测试连接是否成功，下图表示访问成功。 1$ ssh -t git@github.com 在Github上创建一个Git仓库。 此时如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第8步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to …的错误,这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，解决方法见第8步。 Github 和 Git 的关联。 Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，注意origin后面加的是你Github上创建好的仓库的地址。根据创建好的Git仓库页面的提示，可以在本地blog仓库的命令行输入。 1$ git remote add origin https://github.com/ZouJoshua/pelican-blog.git 解决办法： 12先输入：$ git remote rm origin再输入：$ git remote add origin https://github.com/ZouJoshua/pelican-blog.git 关联完成之后把本地库的所有内容推送到远程仓库（也就是Github）上 1$ git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了。 1$ git push origin master 此时，推送时，会出现如下错误： 这是由于新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并： 1$ git pull --rebase origin master 然后再git push，登录Github查看，就会将自己的项目上传到Github。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采用Pelican+Github搭建数据科学博客]]></title>
    <url>%2F2017%2F07%2F01%2F%E9%87%87%E7%94%A8Pelican%2BGithub%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 在今年的个人计划中，想要搭建一个数据挖掘的平台，主要目的是，希望通过这件事能让自己对数据挖掘、机器学习的各种算法都很熟练，同时对搭建这样的平台框架有个基础的实践与认知。因此，就想在做这件事的时候能将自己趟过的坑记录整理下来，帮助自己从技术上提高。所以，首先得搭建一个自己的博客。虽然，目前网上有很多现成的博客系统，但是自己总觉得自定义的才是最炫酷的（其实并没有什么卵用），希望能一直坚持下来吧。本文采用 Python 的 Pelican 库搭建数据科学博客，并将 blog 挂在 Github Pages 上。 环境Pelican是一套开源的使用Python编写的博客静态生成, 可以添加文章和和创建页面, 可以使用MarkDown，reStructuredText和AsiiDoc的格式来书写, 同时使用 Disqus评论系统, 支持 RSS和Atom输出, 插件, 主题, 代码高亮等功能, 采用Jajin2模板引擎, 可以很容易的更改模板，也可以很容易的把文章部署到 GitHub Pages 让别人阅读，欢迎进入我的Blog 站点进行效果预览。 本地环境windows 10 64位/ubuntu 16.04（笔记本为win10，台式机为ubuntu系统） Python 3.5 服务器环境Github Pages（把 Github 的仓库当成服务器） 安装安装Python如果你还没有安装 Python ，建议使用 Python 3.5，可以到官网安装。 安装Pelican建议在 Virtualenv （Python虚拟环境）下使用，创建并激活一个虚拟环境。 12345virtualenvs blogs # 创建blog的虚拟环境cd blogs/scriptspip pelicanactivate # 激活虚拟环境mkdir blog # 创建blog目录 安装Markdown12cd blogs/scriptspip install markdown 博客框架通过初始化 Pelican 设置生成一个基本的博客框架，在创建的文件夹下运行 pelican-quickstart 时，会开始一个交互式博客安装过程。根据提示一步一步输入相应的配置项，对于不了解 pelican 框架或第一次安装的情况下，大多数问题直接点击Enter接受默认即可，后续可以在pelicanconf.py文件里更改配置，个人pelicanconf.py详细配置。 1234567891011121314151617181920212223(blogs) D:\Python\envs\blogs\blog&gt;pelican-quickstartWelcome to pelican-quickstart v3.7.1.This script will help you create a new Pelican-based website.Please answer the following questions so this script can generate the files needed by Pelican.&gt; Where do you want to create your new web site? [.]&gt; What will be the title of this web site? Joshua's Blog&gt; Who will be the author of this web site? Joshua Zou&gt; What will be the default language of this web site? [Chinese (Simplified)]&gt; Do you want to specify a URL prefix? e.g., http://example.com (Y/n) n&gt; Do you want to enable article pagination? (Y/n)&gt; How many articles per page do you want? [10]&gt; What is your time zone? [Europe/Paris] Asia/Shanghai&gt; Do you want to generate a Fabfile/Makefile to automate generation and publishing? (Y/n) &gt; Do you want an auto-reload &amp; simpleHTTP script to assist with theme and site development? (Y/n)&gt; Do you want to upload your website using FTP? (y/N)&gt; Do you want to upload your website using SSH? (y/N)&gt; Do you want to upload your website using Dropbox? (y/N)&gt; Do you want to upload your website using S3? (y/N)&gt; Do you want to upload your website using Rackspace Cloud Files? (y/N)&gt; Do you want to upload your website using GitHub Pages? (y/N)Done. Your new project is available at D:\Python\envs\blogs\blog 完成后会在相应的目录里生成如下基础框架结构及文件： 123456789blog/├── content # 存储Blog文件的目录，这个目录及子目录下的所有md和rst文件都会被转成html│ └── (pages) # Blog文件，如*.md、*.ipynb等文件├── output # 将blog文件转化成相应的html及相应文件的存放目录├── develop_server.sh # pelican简易web服务器操作文件├── Makefile # 方便管理博客的Make命令文件├── fabfile.py # 与make类似，可用fab publish，fab server命令├── pelicanconf.py # 本地开发时的配置文件└── publishconf.py # 发布时的配置文件，可删除 后续配置完整后，框架如下： 1234567891011121314151617181920blog/|--content # 存储Blog文件的目录，这个目录及子目录下的所有md和rst文件都会被转成html| └──(pages) # Blog文件，如*.md、*.ipynb等文件|--output # 将blog文件转化成相应的html及相应文件的存放目录 └──.git # 执行git init之后，产生的远程仓库目录| └──author # 作者目录，存放pelicanconf.py中指定的Author文件| └──category # 分类目录，默认目录文件为misc，在编辑器中指定| └──feeds # 目录，pelicanconf.py中FEED_RSS指定的XML文件| └──articles # 目录，pelicanconf.py中ARTICLE_URL指定格式分类文件| └──tag # 目录，存放编辑器开头所指定的Tag| └──theme # 目录，存放博客模板文件| └──archives.html,authors.html,categories.html,index.html, tags.html|——pelican-plugins # 目录，pelican插件|——pelican-themes # 目录，pelican主题|——develop_server.sh # pelican简易web服务器操作文件|——Makefile # make 命令文件|——fabfile.py # 与make类似，可用fab publish, fab server命令|——pelicanconf.py # 本地开发时的配置文件|——publishconf.py # 发布时的配置文件，可删除|——.gitignore # 上传Git时排除指定类型文件 主题设置123git clone https://github.com/getpelican/pelican-themes.git # 获取全部主题cd pelican-themespelican-themes -i BT3-Flat #可换成你自己的theme 因为个人喜好不同，我选择了 BT3-Flat 这个主题，但是由于原主题部分文件的问题，我自己修改了模板同时在pelicanconf.py文件中修改 1THEME = './pelican-themes/BT3-Flat' # 设置的主题所在根目录下的路径 Plugin设置1git clone https://github.com/getpelican/pelican-plugins.git # 将所支持的插件clone到本地,方便使用 Jupyter插件Pelican默认情况下并不支持使用jupyter写博客 – 我们需要安装插件来进行支持。我们将把插件以git submodule的方式进行安装以便于管理。 执行git init将当前文件夹初始化为一个git仓库。 创建plugins文件夹 在plugins文件夹中执行git submodule add https://github.com/danielfrg/pelican-ipynb.git plugins/ipynb来添加插件 为了启动插件，我们需要修改pelicanconf.py并将以下内容添加到尾部： 123MARKUP = ('md', 'ipynb')PLUGIN_PATHS = [ './plugins' ] # 如果像原文直接PLUGIN_PATH = `./plugins`而不使用列表会报warningPLUGINS = ['ipynb.markup'] 后期在本地测试时发现，加上Jupyter后，部分功能未显示，所以暂时没把Jupyter功能放入进去，所以目前文档只支持Markdown。 JIATHIS社会化分享功能在pelicanconf.py文件中配置： 1JIATHIS = True Blog Search在 Swiftype注册账号，得到输入自己的blog网址得到 API ，然后在 pelicanconf.py 中添加 1SWIFTYPE = 'swiftype_api' Disqus第三方评论开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。第三方评论系统有很多，这里选用很流行的Disqus作为第三方评论系统，在Disqus上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。 12Site name: &#123;your git account name&#125;.github.ioAdmin URL: &#123;Shortname&#125;.disqus.com 然后同理，在pelicanconf.py添加： 1DISQUS_SITENAME = Shortname 由于DISQUS是国外的第三方应用，所以如果在国内想看到得FQ，后期争取支持国内友言之类的应用。 BlogRoll和Social设置设置一些Blog链接，通过设置LINKS实现,可链接到别人的blog，或者自己的社交圈。在pelicanconf.py文件中配置： Blogroll12LINKS = (('Python.org', 'http://python.org/'), ('Jinja2', 'http://jinja.pocoo.org/'),) Social widget123456SOCIAL = (('weibo','http://www.weibo.com/233499456'), ('envelope','mailto:joshua_zou@163.com'), ('twitter', 'https://twitter.com/joshua_zou'), ('facebook','https://www.facebook.com/joshua.zou.127'), ('linkedin', 'https://www.linkedin.com/in/%E5%B8%85-%E9%82%B9-736390135/'), ('github','https://github.com/ZouJoshua')) Feed设置12FEED_RSS = "feeds/all.rss.xml" CATEGORY_FEED_RSS="feeds/%s.rss.xml" #为分类添加Feed 撰写并发布第一篇blog插件配置等都完成后，就可以开始书写第一篇Blog了。 创建一个Markdown文件，书写自己想记录的blog内容。 在Markdown文件开头加入文档的头信息。 把书写完成的Markdown文件复制到content目录下。 1234567Title: Pelican搭建博客 # blog的标题Author: Joshua # blog作者名字Date: 2017/7/7 14:02:40 # blog发布日期Category: Pelican # blog分类Tags: pelican，python，blogs # blog的标签Slug: pelican-blog # blog在服务器上的路径，是文档的唯一标识，生成html时直接用这个值做html的文件名，个人采用的是当前的时间戳 Summary: My first post,read it to find out. # blog的摘要 将完成的 Markdown 生成 HTML在blog目录下运行命令。 123pelican content # 将content目录下的markdown文件生成html文件，输出到output文件里cd outputpython -m http.server # 启动本地服务器预览blog 在浏览器里访问 localhost:8000 来预览你的博客。 发布博客站点的三种方法Pelican命令 1pelican content -s publishconf.py Fabric 12345pip install fabricfab buildfab regeneratefab servefab publish Make 12345make htmlmake regeneratemake servemake devserver./develop_server.sh stop make 命令不是 Windows 系统自带的dos命令，需要安装，点此下载，根据自己电脑选择32位或64位。安装完成后，须将安装路径添加到系统环境变量。 个人常选用 pelican 命令及 make 命令组合将新生成的 html 文件发布到 Github Pages 。 GitHub Pages的创建和 Git 本地仓库配置要将 blog 部署到 Github 上，必须在本地建立一个 Git 仓库，同时必须确保在 Github server 端有远程仓库，名字一般为 username.github.io 。 GitHub Pages 是 GitHub 的一项功能，允许你快速部署静态网站，让所有人都可以通过特定 URL 访问。为了完成它的配置，我们需要： 注册一个 GitHub 帐号，如果你还没有的话。 创建一个叫 username.github.io 的仓库，这里 username 是你的 GitHub 用户名。这里有更详细的说明。 本部分 Git 本地仓库的配置，可参考此博文。 创建一个叫做 .gitignore 的文件，并添加入这个文件的内容。最终我们将会把文件提交到 Git ，.gitignore将会排除指定类型的文件。 123456cd outputgit init # 产生一个.git文件夹git remote add origin https://github.com/****/****.github.io.git #将远程仓库配置到本地git add .git commit -m "commit blog"git push -u origin master 对于后期的更新，如果需要修改远程仓库，可以选用下面命令之一，先将远程仓库配置到本地，然后进入本地远程仓库目录进行修改，最终提交。 12345git clone https://github.com/****/****.github.io.git #将远程仓库克隆到本地cd xxx(clone到本地的仓库路径）git rm -rf xxx # 删除文件夹git commit -m "Delete some files." # 提交修改git push origin xxx # 将修改提交到远程仓库的分支或主支 设置一键上传部署到 Github打开根目录下的Makefile文件，修改以下三个地方： 12345OUTPUTDIR=$(BASEDIR)/output/ #本地博客仓库路径publish: $(PELICAN) $(INPUTDIR) -o $(OUTPUTDIR) -s $(CONFFILE) $(PELICANOPTS) #可修改OUTPUTDIR,发布的blog站点的输出路径github: publish cd OUTPUTDIR ; git add . ; git commit -am 'your comments' ; git push 设置完后，以后写完文章就可以通过在blog根目录下执行make github进行一键部署了。 可在Makefile文件中增加如下命令，有新文章要发布时可用 make upload一键更新到 Github 上。 12upload: cd $(OUTPUTDIR) &amp;&amp; git add -A &amp;&amp; git commit -am "update blog" &amp;&amp; git push origin master 其实，命令文章的更新上传本质还是用 Git 命令的，只不过 make 命令可以将 Git 命令整合后一键操作，自然比一个一个命令去上传更新来的快。 问题在博客搭建的过程中，趟过的一些坑。 因本人关注数据挖掘、数据分析、算法方面的内容，所以希望用Jupyter Notebook 及 Markdown 搭建一个数据科学博客，但是所选用的这个主题对Jupyter Notebook的插件支持并不好，同时用两种文件方式的时候，整个主题的部分功能显示不全，但不影响总体使用，对这个小瑕疵并不感冒的可以将 Jupyter 插件加入，但是本人有些轻度完美主义，所以暂时先选择Markdown来写。 对于BT3-Flat原主题模板文件，出现部分错误，在此基础上进行改进，同时在主题模板文件中加入JIATHIS社会化分享功能所必须的 css 文件和 js 文件，使得主题支持社会化分享功能。 对于DISQUS第三方评论插件的显示问题。由于DISQUS是国外的，在国内浏览的话会被Q的，如果可以FQ，是可以使用的。 由于个人不太懂css响应式布局，所以在手机端显示会有一些问题，稍后研究完再进行修改。]]></content>
      <categories>
        <category>Pelican</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>git</tag>
        <tag>pelican</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F11%2FTest%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo-blog</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>